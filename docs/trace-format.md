# CPQ Trace File Format

This document describes the structure and format of Infor CPQ interactive trace files that are parsed by the CPQ Trace Analyzer.

---

## Overview

**What:** Infor CPQ interactive trace files are plain text debug logs generated by the CPQ configuration engine during product configuration sessions.

**Purpose:** These traces provide detailed insights into:
- Configuration metadata (instance, application, part info)
- Feature selections and available options
- Rule execution flow and order
- Variable assignments and value changes
- Condition evaluations (true/false)
- Integration output generation
- Performance and debugging information

**Format:** Plain text with structured sections, XML header, and consistent patterns for different data types.

**Typical Size:** 10KB - 5MB (depends on configuration complexity and rule count)

---

## File Structure

```
┌─────────────────────────────────────┐
│  XML Header                         │
│  - Instance, Application            │
│  - ConfigurationID                  │
│  - PartNumber, Namespace            │
│  - ConfigurationMode                │
│  - HeaderID                         │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│  Configuration Metadata             │
│  - Timestamp                        │
│  - User information                 │
│  - Session details                  │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│  Rule Executions                    │
│  - Ruleset: <name> Rule: <id>       │
│  - RuleType                         │
│  - Conditions                       │
│  - Variables                        │
│  - Nested LoadRulesetRule           │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│  Screen Option Sections             │
│  - Feature definitions              │
│  - Available options                │
│  - Selected values                  │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│  Integration Outputs                │
│  - Template: <name>                 │
│  - Properties and values            │
│  - IntegrationOutputID              │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│  Execution Summary                  │
│  - N rules executed                 │
│  - Rollback points                  │
│  - Performance metrics              │
└─────────────────────────────────────┘
```

---

## XML Header Section

### Structure

The trace begins with an XML header containing configuration metadata:

```xml
<InputParameters Instance="PROD" Application="MyApp">
  <ConfigurationID>12345</ConfigurationID>
  <PartNumber>WIDGET-001</PartNumber>
  <PartNamespace>ACME</PartNamespace>
  <ConfigurationMode>Interactive</ConfigurationMode>
  <HeaderID>HDR-67890</HeaderID>
  <Timestamp>2024-01-15T14:30:22Z</Timestamp>
</InputParameters>
```

### Fields

| Field | Description | Example |
|-------|-------------|---------|
| `Instance` | CPQ instance name | "PROD", "UAT", "DEV" |
| `Application` | Application identifier | "MyApp", "Configurator" |
| `ConfigurationID` | Unique configuration session ID | "12345" |
| `PartNumber` | Product/part being configured | "WIDGET-001" |
| `PartNamespace` | Namespace for part definition | "ACME", "CORP" |
| `ConfigurationMode` | Configuration mode | "Interactive", "Batch" |
| `HeaderID` | Reference to order/quote header | "HDR-67890" |
| `Timestamp` | Configuration start time (ISO 8601) | "2024-01-15T14:30:22Z" |

### Parser Pattern

```typescript
// Parser regex patterns
const instancePattern = /<InputParameters Instance="([^"]+)" Application="([^"]+)">/;
const configIdPattern = /<ConfigurationID>(\d+)<\/ConfigurationID>/;
const partNumberPattern = /<PartNumber>([^<]+)<\/PartNumber>/;
```

---

## Rule Execution Sections

### Structure

Each rule execution is logged with this pattern:

```
Ruleset: MyNamespace.MyRuleset Rule: 123 My Rule Description (Ruleset: MyNamespace.MyRuleset)
ConditionRule

  Property : RuleCondition
    Expression : =EXISTS(input.BUS_PROCESS)
    Trace : Exists("CSR")
    Result : True

  Variable : ROOT[infeat]
    Assignment : =input.BUS_PROCESS
    Previous : (unassigned)
    Result : "CSR"

------------------------------------------------------------
```

### Components

#### 1. Rule Header

```
Ruleset: <namespace>.<rulesetName> Rule: <id> <description> (Ruleset: <namespace>.<rulesetName>)
```

**Example:**
```
Ruleset: ACME.Validation Rule: 456 Check User Type (Ruleset: ACME.Validation)
```

**Fields:**
- `namespace.rulesetName`: Fully qualified ruleset identifier
- `id`: Numeric rule ID
- `description`: Human-readable rule name/description

#### 2. Rule Type

Appears on the line immediately after the rule header:

```
ConditionRule
VariableRule
LoadRulesetRule
CreateComponentRule
CreateDynamicOptionListRule
CreateDynamicOptionListGroupRule
ScreenDisplayRule
ForEachRule
LoopRule
ClearUserValueRule
```

#### 3. Rule Properties

Rules contain properties based on their type:

**ConditionRule Properties:**
```
  Property : RuleCondition
    Expression : =<CPQ expression>
    Trace : <evaluation trace>
    Result : True | False
```

**VariableRule Properties:**
```
  Variable : <variableName>
    Assignment : =<expression> or <literal value>
    Previous : <previous value> | (unassigned) | null
    Result : <result value> | null

  Condition Expression : =<expression>
    Condition Result : True | False
```

**LoadRulesetRule Properties:**
```
  Property : RuleCondition
    Expression : =<condition>
    Trace : <evaluation>
    Result : True

  Property : Ruleset
    Result : "<namespace>.<rulesetName>"
```

### Parser Patterns

```typescript
// Rule execution pattern
const rulesetPattern = /^Ruleset: (\S+) Rule: (\d+) (.+?) \(Ruleset:/;
const ruleTypePattern = /^(ConditionRule|VariableRule|LoadRulesetRule|...)/;

// Variable pattern
const variablePattern = /^\s+Variable\s+:\s+(.+)/;
const assignmentPattern = /^\s+Assignment\s+:\s+(.+)/;
const previousPattern = /^\s+Previous\s+:\s+(.+)/;
const resultPattern = /^\s+Result\s+:\s+(.+)/;

// Condition pattern
const expressionPattern = /^\s+Expression\s+:\s+=(.+)/;
const tracePattern = /^\s+Trace\s+:\s+(.+)/;
const resultBoolPattern = /^\s+Result\s+:\s+(True|False)/;
```

---

## Screen Option Sections

Screen Options represent features/fields in the configuration UI.

### Structure

```
Screen Option: <featureName>
  Property : Caption
    Trace : "<display caption>"
    Result : "<display caption>"

  Property : Option List Id
    Result : "<guid>"

  Property : Option List Group
    Result : "<group-guid>"

  Value: "<selectedValue>" | null | (unassigned)

------------------------------------------------------------
```

### Example

```
Screen Option: BUS_PROCESS
  Property : Caption
    Trace : "Business Process"
    Result : "Business Process"

  Property : Option List Id
    Result : "{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}"

  Property : Option List Group
    Result : "{12345678-90AB-CDEF-1234-567890ABCDEF}"

  Value: "CSR"

------------------------------------------------------------
```

### Fields

| Field | Description |
|-------|-------------|
| Feature Name | Internal identifier (e.g., `BUS_PROCESS`) |
| Caption | User-facing label (e.g., "Business Process") |
| Option List Id | GUID referencing full option list definition |
| Option List Group | GUID referencing filtered option group |
| Value | Selected value or null/unassigned |

### Option List Groups

Before Screen Options appear, option groups are defined:

```
  Property : Group Name
    Result : "{12345678-90AB-CDEF-1234-567890ABCDEF}"

  Property : Group Values
    Result : {"CSR", "SALES", "SUPPORT", "ADMIN"}
```

**Parser Logic:**
1. First pass: Build map of Group GUIDs to option arrays
2. Second pass: Match Screen Option's `Option List Group` to GUID
3. Resolve available options for each feature

---

## Integration Output Sections

Integration outputs represent data being sent to external systems.

### Structure

```
  Template: <templateName>

    Property : IntegrationOutputID
      Result : "<outputId>"

    Property : <propertyName1>
      Result : "<value1>"

    Property : <propertyName2>
      Result : <numericValue>

    Property : <propertyName3>
      Result : null

------------------------------------------------------------
```

### Example

```
  Template: OrderLine

    Property : IntegrationOutputID
      Result : "LINE-001"

    Property : ProductCode
      Result : "WIDGET-A"

    Property : Quantity
      Result : 5

    Property : UnitPrice
      Result : 99.99

    Property : DiscountPercent
      Result : null

------------------------------------------------------------
```

### Fields

| Field | Type | Description |
|-------|------|-------------|
| Template | string | Integration template name |
| IntegrationOutputID | string | Unique ID for this output row |
| Properties | key-value | Custom properties specific to template |

**Value Types:**
- String: `"value"` (quoted)
- Number: `123` or `99.99` (unquoted)
- Null: `null`, `{}`, `(unassigned)`

### Parser Logic

Parser groups properties by template:

```typescript
interface IntegrationTemplate {
  name: string;
  columns: string[];  // Property names in order of appearance
  rows: IntegrationOutputRow[];
}

interface IntegrationOutputRow {
  id: string;  // IntegrationOutputID
  properties: Map<string, string | number | null>;
  lineNumber: number;
}
```

---

## Variable Tracking

Variables assignments are logged within rule executions.

### Structure

```
  Variable : <variableName>
    Assignment : =<expression> or <literal>
    Previous : <previousValue> | (unassigned) | null
    Result : <resultValue> | null
```

### Examples

**Simple Assignment:**
```
  Variable : root.Quantity
    Assignment : 10
    Previous : (unassigned)
    Result : "10"
```

**Expression Assignment:**
```
  Variable : root.TotalPrice
    Assignment : =root.Quantity * root.UnitPrice
    Previous : "500"
    Result : "1000"
```

**Indexed Variable (e.g., arrays/maps):**
```
  Variable : ROOT[infeat]
    Assignment : =input.BUS_PROCESS
    Previous : (unassigned)
    Result : "CSR"
```

### Variable Name Resolution

**Indexed Variables:**
- Raw: `ROOT[infeat]`
- Resolved: `root.Feature` (if `infeat` = "Feature")

Parser maintains a map of variable values to resolve indices dynamically.

---

## Condition Evaluations

Conditions control rule firing and flow.

### Structure (ConditionRule)

```
  Property : RuleCondition
    Expression : =<CPQ expression>
    Trace : <evaluation trace showing values>
    Result : True | False
```

### Structure (VariableRule)

```
  Condition Expression : =<CPQ expression>
    Condition Result : True | False
```

### Examples

**Existence Check:**
```
  Property : RuleCondition
    Expression : =EXISTS(input.BUS_PROCESS)
    Trace : Exists("CSR")
    Result : True
```

**Comparison:**
```
  Property : RuleCondition
    Expression : =root.Quantity > 5
    Trace : (10 > 5)
    Result : True
```

**Logical AND:**
```
  Property : RuleCondition
    Expression : =EXISTS(root.ProductType) AND root.Quantity > 0
    Trace : (Exists("Widget") AND (10 > 0))
    Result : True
```

### Trace Field

The `Trace` field shows the expression with values substituted:

- Variables replaced with actual values
- Function results shown
- Nested expressions evaluated

This makes debugging easier by showing exactly what was compared.

---

## Section Dividers

Sections are separated by divider lines:

```
------------------------------------------------------------
```

**Pattern:** 10 or more consecutive hyphens

**Usage:**
- Separates rule executions
- Separates Screen Options
- Separates Integration Outputs
- Indicates end of multi-line sections

**Parser Logic:**
```typescript
const sectionDivider = /^-{10,}/;

if (sectionDivider.test(line)) {
  // End of current section
  break;
}
```

---

## Execution Summary

At the end of the trace, a summary appears:

```
15 rules executed
Rollback point 3
```

### Fields

**Rules Executed:**
```
<N> rules executed
```

- Total count of rule executions (including repeated rules)

**Rollback Points:**
```
Rollback point <N>
```

- Highest rollback point number reached
- Indicates conflict resolution or backtracking
- Multiple rollback points may appear throughout trace

### Parser Patterns

```typescript
const rulesExecutedPattern = /^(\d+) rules executed/;
const rollbackPattern = /Rollback point (\d+)/;
```

---

## Common Patterns

### Property-Value Pattern

Most data follows this pattern:

```
  Property : <PropertyName>
    <Field> : <value>
    <Field> : <value>
```

**Example:**
```
  Property : Caption
    Trace : "Business Process"
    Result : "Business Process"
```

**Parser Logic:**
1. Match `Property : <name>`
2. Look ahead 1-6 lines for field patterns
3. Extract field name and value
4. Stop at next Property or section divider

### Value Formats

**String Values:**
```
Result : "value"          # Quoted
Trace : "text"            # Quoted
```

**Numeric Values:**
```
Result : 123              # Unquoted integer
Result : 99.99            # Unquoted decimal
```

**Boolean Values:**
```
Result : True
Result : False
```

**Null/Empty Values:**
```
Result : null
Result : (unassigned)
Result : {}
Result : ""
```

**Array Values:**
```
Result : {"OPT1", "OPT2", "OPT3"}
```

---

## Expression Syntax

CPQ expressions use a custom syntax parsed by `lib/expression-parser.ts`.

### Operators

**Logical:**
- `AND`
- `OR`
- `NOT`

**Comparison:**
- `=` (equals)
- `<>` (not equals)
- `<`, `>`, `<=`, `>=`

**Arithmetic:**
- `+`, `-`, `*`, `/`

### Functions

**Common Functions:**
```
EXISTS(<variable>)          # Check if variable has value
COUNT(<collection>)         # Count items
SUM(<collection>)           # Sum numeric values
CONTAINS(<string>, <sub>)   # String contains
```

### Examples

```
=EXISTS(input.BUS_PROCESS)
=root.Quantity > 5
=root.TotalPrice = root.Quantity * root.UnitPrice
=CONTAINS(root.ProductName, "Widget")
=root.Enabled AND root.Quantity > 0
```

---

## Line Endings

Traces support both Unix and Windows line endings:

```typescript
const lines = traceContent.split(/\r?\n/);
```

- Unix: `\n` (LF)
- Windows: `\r\n` (CRLF)

---

## Parsing Workflow

### Two-Pass Parsing

1. **First Pass: Build Option Groups Map**
   - Find all `Property : Group Name` sections
   - Extract GUID from `Result`
   - Find matching `Property : Group Values`
   - Parse options array `{"OPT1", "OPT2"}`
   - Build map: `GUID → options[]`

2. **Second Pass: Parse Everything Else**
   - Metadata from XML header
   - Rule executions
   - Screen Options (lookup options via GUID)
   - Integration Outputs
   - Statistics (rules executed, rollback points)

### Line-by-Line Processing

```typescript
for (let i = 0; i < lines.length; i++) {
  const line = lines[i];

  // Pattern matching
  if (rulesetPattern.test(line)) {
    // Parse rule execution
  } else if (screenOptionPattern.test(line)) {
    // Parse screen option
  } else if (templatePattern.test(line)) {
    // Parse integration output
  }
  // ...
}
```

### Look-Ahead Pattern

Many sections require looking ahead to subsequent lines:

```typescript
// Look ahead for Property values
for (let j = i + 1; j < Math.min(i + 10, lines.length); j++) {
  const nextLine = lines[j];

  if (propertyPattern.test(nextLine)) {
    // Found next property, stop looking
    break;
  }

  if (resultPattern.test(nextLine)) {
    // Extract value
    const value = extractValue(nextLine);
    break;
  }
}
```

**Typical Look-Ahead Distance:** 4-10 lines (depends on section complexity)

---

## Common Parsing Issues

### 1. Incomplete Traces

**Symptom:** Trace ends abruptly mid-section

**Cause:**
- Configuration error/crash
- Timeout
- File corruption

**Parser Behavior:**
- Partial data returned
- `parseErrors` array may contain warnings
- Missing sections show as empty/null

---

### 2. Malformed Expressions

**Symptom:** Expression cannot be parsed into AST

**Example:**
```
Expression : =INVALID((SYNTAX
```

**Parser Behavior:**
- Expression stored as plain string
- AST parsing fails gracefully
- Expression tree shows raw text

**Impact:**
- UI can still display expression
- Search/filtering still works
- Tree visualization disabled for that expression

---

### 3. Missing Sections

**Symptom:** Expected section not found in trace

**Causes:**
- Feature not configured to log
- Ruleset never executed
- Integration not triggered

**Parser Behavior:**
- Section arrays/maps are empty
- Summary counts reflect actual data
- No errors thrown (empty is valid)

---

### 4. Encoding Issues

**Symptom:** Special characters corrupted

**Example:**
```
Caption : "R?sum?" (should be "Résumé")
```

**Cause:**
- Wrong character encoding (not UTF-8)
- Copy-paste from non-Unicode source

**Parser Behavior:**
- Values stored as-is
- May affect search/comparison

**Fix:**
- Ensure trace saved as UTF-8
- Re-export from CPQ with UTF-8 encoding

---

### 5. Duplicate Section Markers

**Symptom:** Same rule ID appears multiple times

**Cause:**
- Rule executed multiple times (loops, recursion)
- This is often expected behavior

**Parser Behavior:**
- Each execution tracked separately
- Execution count incremented
- Timeline shows all executions in order

---

### 6. GUID Mismatches

**Symptom:** Screen Option references Group GUID not found in first pass

**Cause:**
- Option List Group defined after usage
- Trace truncated before group definition

**Parser Behavior:**
- Feature shows empty options array `[]`
- No error thrown
- Feature still displayed with no options

---

## Validation

### Well-Formed Trace Checklist

A well-formed CPQ trace should have:

- [x] XML header with all required fields
- [x] At least one rule execution
- [x] Screen Option sections for features
- [x] Section dividers between major sections
- [x] "N rules executed" summary at end
- [x] Consistent indentation (2 spaces per level)
- [x] Matching Property/Field patterns

### Parser Validation

The parser performs validation:

```typescript
export interface ParsedTrace {
  // ...
  parseErrors: string[];  // Any errors/warnings during parsing
}
```

**Check for Issues:**
```typescript
if (trace.parseErrors.length > 0) {
  console.warn('Parse errors:', trace.parseErrors);
}
```

---

## Performance Considerations

### Typical Parse Times

| Trace Size | Line Count | Parse Time |
|------------|------------|------------|
| Small | 1K - 5K lines | < 100ms |
| Medium | 5K - 20K lines | 100ms - 500ms |
| Large | 20K - 100K lines | 500ms - 2s |
| Very Large | > 100K lines | 2s+ |

### Optimization Strategies

**For Large Files:**
1. **Stream Processing:** Parse line-by-line (already implemented)
2. **Early Exit:** Stop parsing when target data found (future)
3. **Worker Threads:** Parse in background thread (future)
4. **Server-Side Parsing:** Parse on server for very large files (future with Supabase)

---

## Example Trace Snippet

Here's a complete example showing multiple sections:

```xml
<InputParameters Instance="PROD" Application="Configurator">
  <ConfigurationID>98765</ConfigurationID>
  <PartNumber>LAPTOP-PRO</PartNumber>
  <PartNamespace>TECH</PartNamespace>
  <ConfigurationMode>Interactive</ConfigurationMode>
  <HeaderID>ORD-12345</HeaderID>
</InputParameters>

Ruleset: TECH.Initialization Rule: 1 Set Default Values (Ruleset: TECH.Initialization)
VariableRule

  Variable : root.ProductType
    Assignment : "Laptop"
    Previous : (unassigned)
    Result : "Laptop"

------------------------------------------------------------

Ruleset: TECH.Features Rule: 10 Load Feature Options (Ruleset: TECH.Features)
LoadRulesetRule

  Property : RuleCondition
    Expression : =EXISTS(root.ProductType)
    Trace : Exists("Laptop")
    Result : True

  Property : Ruleset
    Result : "TECH.LaptopOptions"

------------------------------------------------------------

  Property : Group Name
    Result : "{ABCD1234-5678-90EF-GHIJ-KLMNOPQRSTUV}"

  Property : Group Values
    Result : {"i5", "i7", "i9"}

------------------------------------------------------------

Screen Option: PROCESSOR
  Property : Caption
    Trace : "Processor"
    Result : "Processor"

  Property : Option List Group
    Result : "{ABCD1234-5678-90EF-GHIJ-KLMNOPQRSTUV}"

  Value: "i7"

------------------------------------------------------------

  Template: ConfigurationOutput

    Property : IntegrationOutputID
      Result : "CFG-001"

    Property : ProductCode
      Result : "LAPTOP-PRO-I7"

    Property : ProcessorType
      Result : "i7"

    Property : Price
      Result : 1299.99

------------------------------------------------------------

5 rules executed
Rollback point 1
```

---

## Summary

**Key Points:**

1. **Structured Text:** Plain text with consistent patterns
2. **XML Header:** Contains configuration metadata
3. **Rule Executions:** Show flow, conditions, variables
4. **Screen Options:** Feature definitions with available/selected values
5. **Integration Outputs:** Data for external systems
6. **Two-Pass Parsing:** First for option groups, second for everything else
7. **Line-by-Line:** Sequential processing with look-ahead
8. **Graceful Degradation:** Parser handles incomplete/malformed traces

**For Developers:**

Refer to `lib/trace-parser.ts` for complete parsing implementation (2,213 lines) with detailed regex patterns and data extraction logic.
